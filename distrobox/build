#!/bin/bash
set -euo pipefail

# Distrobox Image Builder
# =======================
#
# This script builds container images for use with Distrobox
# on atomic Linux systems.
#
# Builds are powered by a config file, not unlike what Distrobox
# provides as built-in functionality. However, unlike Distrobox,
# build steps are persisted as container image layers. This allows
# for more stability: a container can be recreated from a known
# state instead of re-running a set of build steps and hoping
# for the best.

# Path to the build config file for the container.
build_config=${1:-}

# Name of the build phase to start the build from.
#
# Build phases that occur before the given phase will
# be skipped; an existing container image will be used.
#
# This is useful for rapidly testing changes in later
# build phases.
#
# Note: it is an error to start from a build phase that has
# never been run.
initial_build_phase=${2:-}

# Stores the previous phase's image. This is used to provide
# a working container for each build phase.
previous_phase_image=''

function main() {
	source "$build_config"

	# Run build steps from the build config directory so that files are
	# referenced relative to the build config.
	build_config_dir=$(dirname "$build_config")
	cd "$build_config_dir"

	validate_initial_build_phase
	validate_build_config
	run_build_phases

	local latest_img=$(full_image_name "$image_name" 'latest')
	local do_root_img_copy=0
	if [[ "$rootful_container" == 'true' ]]; then
		local root_latest_img=$(sudo podman images -q "$latest_img")
		if [[ "$initial_build_phase" != 'distrobox_configure' ]] || [[ -z "$root_latest_img" ]]; then
			# Either the image was rebuilt, or root storage does not currently
			# have a copy of the image. The image should be copied to root
			# storage.
			do_root_img_copy=1
		fi
	fi

	if [[ "$do_root_img_copy" == '1' ]]; then
		copy_image_to_root_storage "$latest_img"
	fi

	distrobox_configure
}

function buildah() {
	printf '+ buildah %s\n' "$*" >&2
	command buildah "$@"
}

function distrobox() {
	printf '+ distrobox %s\n' "$*" >&2
	command distrobox "$@"
}

# Joins all arguments together by the given delimiter.
function join() {
	local delimiter=$1
	shift

	python3 -c 'import sys; print(sys.argv[1].join(sys.argv[2:]))' "$delimiter" "$@"
}

# Discovers additional volumes on the system that should be mounted
# into the container.
function addl_volumes() {
	local mount_dirs=$(awk '{ print $2 }' <'/proc/mounts')

	# These mounts, and any mounts underneath them, will never be
	# explicitly added as a distrobox container volume.
	local excluded_prefixes=(
		'/boot'
		'/dev'
		'/proc'
		'/tmp'
		'/run'
		'/var/lib/containers'
		'/var/lib/nfs'
		'/sys'
		'/sysroot'
	)

	# These mounts will be excluded as distrobox container volumes.
	#
	# Mounts underneath them may still be added as distrobox container volumes.
	local excluded_directories=(
		'/'
		'/etc'

		# Distrobox should include these automatically.
		'/var'
		'/var/home'
	)
	printf '%s' "$mount_dirs" |
		grep -v -E \
			-e "^($(join '|' "${excluded_prefixes[@]}"))(/|$)" \
			-e "^($(join '|' "${excluded_directories[@]}"))$"
}

function run_build_phases() {
	local run_this_build_phase=0
	local p

	# The first build phase is always based on the container source image.
	local previous_phase_image=$src_image

	# The container image for the current build phase.
	local current_phase_image

	# The first build phase requires a source image.
	#
	# It should always be pulled so that it is up-to-date.
	local buildah_from_pull='always'

	# The current working container.
	local working_ctr

	# If the initial build phase is "distrobox_configure", there's nothing
	# to do here. Bail early.
	#
	# This isn't technically necessary but it does save an unsightly
	# `buildah tag` invocation.
	if [[ "$initial_build_phase" == 'distrobox_configure' ]]; then
		return 0
	fi

	for p in "${build_phases[@]}"; do
		current_phase_image=$(full_image_name "$image_name" "$p")

		if [[ "$p" == "$initial_build_phase" ]]; then
			run_this_build_phase=1
		fi

		if [[ "$run_this_build_phase" == 1 ]]; then
			working_ctr="$(buildah from --pull="$buildah_from_pull" "$previous_phase_image")"
			run_single_build_phase "$p" "$working_ctr"
			printf 'Committing to image %s\n' "$current_phase_image" >&2
			buildah commit "$working_ctr" "$current_phase_image"
			buildah rm "$working_ctr"
		fi
		previous_phase_image=$current_phase_image

		# After the first build phase, intermediate images will only
		# exist locally. Pulls should never be attempted.
		buildah_from_pull='never'
	done
	buildah tag "$previous_phase_image" "$(full_image_name "$image_name" 'latest')"
}

function run_single_build_phase() {
	local phase=$1
	local working_ctr=$2
	{
		printf '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n'
		printf '    Build Phase %s\n' "$p"
		printf '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n'
	} >&2
	"build_phase_${phase}" "$working_ctr"
	{
		printf '<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n'
		printf '    Completed Build Phase %s\n' "$p"
		printf '<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n'
	} >&2
}

function copy_image_to_root_storage() {
	local ctr=$1
	local image_path="localhost::${1}"

	{
		printf '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n'
		printf '    Copying Image to Root Storage\n'
		printf '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n'
	} >&2

	sudo podman image scp "$(id -u)@${image_path}" "root@${image_path}"

	{
		printf '<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n'
		printf '    Completed Copying Image to Root Storage\n'
		printf '<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n'
	} >&2
}

function distrobox_configure() {
	if [[ -n "${DISTROBOX_ENTER_PATH:-}" ]]; then
		printf 'cannot run distrobox creation step from within distrobox\n' >&2
		printf 'run build from "distrobox_configure" step on host\n' >&2
		exit 16
	fi
	local rootful_args=()
	if [[ "$rootful_container" ]]; then
		rootful_args=('--root')
	fi

	distrobox rm "${rootful_args[@]}" -f "$distrobox_name"

	local addl_volume_flags=()
	while read -r v; do
		if [[ -z "$v" ]]; then
			continue
		fi
		addl_volume_flags+=('--volume' "${v}:${v}:rw")
	done <<<"$(addl_volumes)"

	distrobox create \
		--name "$distrobox_name" \
		--image "$(full_image_name "${image_name}" 'latest')" \
		--hostname "${distrobox_name}.$(hostname -s)" \
		--additional-flags "-e DISTROBOX_NAME=${distrobox_name}" \
		"${rootful_args[@]}" \
		"${addl_volume_flags[@]}" \
		"${addl_distrobox_args[@]}" \
		--yes
}

function validate_script_arguments() {
	if [[ -z "$build_config" ]]; then
		printf 'fatal: expected first parameter to be path to build config\n' >&2
		exit 1
	fi

	if [[ -z "$initial_build_phase" ]]; then
		printf 'fatal: expected second parameter to be initial build phase\n' >&2
		exit 1
	fi
}

function validate_build_config() {
	for reqd_config in addl_distrobox_args build_phases distrobox_name image_name src_image; do
		if ! [[ -v "${reqd_config}" ]]; then
			printf 'fatal: build config missing required parameter %s\n' "$reqd_config" >&2
			exit 2
		fi
	done

	if [[ "${#build_phases[@]}" == 0 ]]; then
		printf 'fatal: must have at least one build phase\n' >&2
		exit 3
	fi

	local missing_build_phase_func=0
	local p
	for p in "${build_phases[@]}"; do
		if ! type "build_phase_${p}" >/dev/null 2>&1; then
			printf 'fatal: missing required build phase function build_phase_%s\n' "$p" >&2
			missing_build_phase_func=1
		fi
	done
	if [[ "$missing_build_phase_func" == 1 ]]; then
		exit 4
	fi
}

function validate_initial_build_phase() {
	local p
	local initial_build_phase_is_valid=0

	if [[ "$initial_build_phase" == 'distrobox_configure' ]]; then
		return 0
	fi

	for p in "${build_phases[@]}"; do
		if [[ "$initial_build_phase" == "$p" ]]; then
			initial_build_phase_is_valid=1
			break
		fi
	done

	if [[ "$initial_build_phase_is_valid" == 0 ]]; then
		{
			printf 'selected initial build phase is not valid; expected one of: '
			for p in "${build_phases[@]}"; do
				printf '"%s", ' "$p"
			done
			printf '"distrobox_configure"\n'
		} >&2
		exit 1
	fi
}

function full_image_name() {
	local image_name=$1
	local build_phase=$2

	printf 'localhost/%s:%s' "$image_name" "$build_phase"
}

main
# vim: noet
